# ===================================
# Shelly 1PM Mini Gen3 Configuration
# ===================================
# Enhanced ESPHome configuration with:
# - Power metering (BL0942) and overpower protection
# - Configurable overheating protection with hysteresis
# - Configurable relay restore mode
# - BLE scanner mode select (Disabled/Passive)
# - Comprehensive monitoring and diagnostics
# ===================================

substitutions:
  device_name: shelly-1pm-mini-gen3
  friendly_name: Shelly 1PM Mini Gen3
  project_name: dafal_esphome-configs.shelly_1pm_mini_gen3
  project_version: 1.0.0
  area: ""

# ===================================
# Device & Platform Configuration
# ===================================

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  project:
    name: ${project_name}
    version: ${project_version}
  area: ${area}
  on_boot:
    priority: -100  # Run after all components initialized
    then:
      - lambda: |-
          // Apply relay restore mode on boot with full logic
          std::string mode = id(relay_restore_mode).current_option();
          bool last_state = id(relay_last_state);
          float temp = id(temperature).state;
          bool temp_ok = isnan(temp) || temp < (id(overheat_threshold).state - id(temp_hysteresis).state);

          ESP_LOGI("boot", "Applying relay restore mode: %s", mode.c_str());
          ESP_LOGI("boot", "Last relay state: %s", last_state ? "ON" : "OFF");
          ESP_LOGI("boot", "Temperature: %.1f°C, OK: %s", temp, temp_ok ? "YES" : "NO");

          if (mode == "Always OFF") {
            ESP_LOGI("boot", "Mode: Always OFF - forcing relay OFF");
            id(relay).turn_off();

          } else if (mode == "Always ON") {
            if (temp_ok) {
              ESP_LOGI("boot", "Mode: Always ON - forcing relay ON (temp OK)");
              id(relay).turn_on();
            } else {
              ESP_LOGW("boot", "Mode: Always ON - temperature too high, keeping OFF");
              id(relay).turn_off();
            }

          } else if (mode == "Restore (default OFF)") {
            if (last_state && temp_ok) {
              ESP_LOGI("boot", "Mode: Restore (default OFF) - restoring ON state (temp OK)");
              id(relay).turn_on();
            } else {
              ESP_LOGI("boot", "Mode: Restore (default OFF) - defaulting to OFF");
              id(relay).turn_off();
            }

          } else if (mode == "Restore (default ON)") {
            if (!last_state) {
              ESP_LOGI("boot", "Mode: Restore (default ON) - last state was OFF, staying OFF");
              id(relay).turn_off();
            } else if (temp_ok) {
              ESP_LOGI("boot", "Mode: Restore (default ON) - restoring ON state (temp OK)");
              id(relay).turn_on();
            } else {
              ESP_LOGW("boot", "Mode: Restore (default ON) - temperature too high, keeping OFF");
              id(relay).turn_off();
            }
          }

          // Reset latches on boot
          id(overtemp_latched) = false;
          id(overpower_latched) = false;

          // If starting in Pulse Counter mode, publish current count once
          if (id(switch_mode).current_option() == "Pulse Counter") {
            id(pulse_counter_sensor).publish_state(id(pulse_counter));
          }

          // Schedule BLE scanner restore after preferences load
          auto saved_ble = id(ble_scan_mode).current_option();
          ESP_LOGI("boot", "BLE restore scheduled: %s", saved_ble.c_str());
      - delay: 1s
      - script.execute: restore_ble_mode

esp32:
  variant: esp32c3
  flash_size: 8MB
  framework:
    type: esp-idf
    version: recommended
    sdkconfig_options:
      COMPILER_OPTIMIZATION_SIZE: y

# Improve stability on ESP32-C3
preferences:
  flash_write_interval: 5min

# ===================================
# Global Variables
# ===================================

globals:
  - id: relay_last_state
    type: bool
    restore_value: true
    initial_value: 'false'
  - id: overtemp_latched
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: overpower_latched
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: pulse_counter
    type: int
    restore_value: true
    initial_value: '0'
  - id: pulse_cycle_started
    type: bool
    restore_value: false
    initial_value: 'false'

# ===================================
# Network Configuration
# ===================================

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "esphome"
    password: !secret fallback_password
  on_connect:
    - logger.log: "WiFi connected"
  on_disconnect:
    - logger.log: "WiFi disconnected"

captive_portal:

mdns:
  disabled: false

# ===================================
# Home Assistant Integration
# ===================================

api:
  reboot_timeout: 0s
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

# ===================================
# Web Interface
# ===================================

web_server:
  port: 80
  version: 3
  log: true

# ===================================
# Bluetooth Proxy / Scanner
# ===================================

esp32_ble_tracker:
  id: ble_tracker
  scan_parameters:
    continuous: false
    active: false
  on_ble_advertise:
    - lambda: |-
        static uint32_t last = 0;
        const uint32_t now = millis();
        if (now - last < 5000) return;
        if (x.get_rssi() > -90) {
          ESP_LOGD("ble_adv", "BLE adv %s RSSI %d", x.address_str().c_str(), x.get_rssi());
          last = now;
        }

bluetooth_proxy:
  active: true

# ===================================
# Logging & Status
# ===================================

logger:
  level: DEBUG
  baud_rate: 115200

status_led:
  pin:
    number: GPIO0
    inverted: true

# ===================================
# UART (BL0942)
# ===================================

uart:
  id: bl0942_uart
  tx_pin: GPIO6
  rx_pin:
    number: GPIO7
    mode:
      pullup: true
      input: true
  baud_rate: 9600
  stop_bits: 1

# ===================================
# Sensors
# ===================================

sensor:
  # Temperature monitoring with NTC sensor
  - id: temperature
    name: "Temperature"
    platform: ntc
    sensor: temperature_sensor_resistance
    icon: "mdi:thermometer"
    entity_category: diagnostic
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    calibration:
      b_constant: 3350
      reference_resistance: 10kOhm
      reference_temperature: 25°C
    filters:
      - sliding_window_moving_average:
          window_size: 5
          send_every: 5
      - heartbeat: 60s

  - id: temperature_sensor_resistance
    platform: resistance
    sensor: temperature_sensor_voltage
    configuration: DOWNSTREAM
    resistor: 10kOhm

  - id: temperature_sensor_voltage
    platform: adc
    pin: GPIO3
    attenuation: 12db
    update_interval: 10s

  # BL0942 power metering
  - platform: bl0942
    uart_id: bl0942_uart
    voltage:
      name: "Voltage"
      id: bvoltage
      icon: "mdi:alpha-v-circle-outline"
      device_class: voltage
    current:
      name: "Current"
      id: bcurrent
      icon: "mdi:alpha-a-circle-outline"
      device_class: current
    power:
      name: "Power"
      id: bpower
      icon: "mdi:transmission-tower"
      device_class: power
      on_value:
        then:
          - lambda: |-
              float limit = id(power_limit).state;
              float clear_th = limit * 0.9f;
              if (id(relay).state && x > limit) {
                if (!id(overpower_latched)) {
                  id(overpower_latched) = true;
                  id(error_overpower).publish_state(true);
                  ESP_LOGE("power", "Overpower: %.1f W > %.1f W. Cutting relay.", x, limit);
                  id(relay).turn_off();
                }
              } else if (id(overpower_latched) && x < clear_th) {
                id(overpower_latched) = false;
                id(error_overpower).publish_state(false);
                ESP_LOGI("power", "Overpower cleared: %.1f W < %.1f W", x, clear_th);
              }
    energy:
      name: "Energy"
      id: benergy
      icon: "mdi:lightning-bolt"
      device_class: energy
    frequency:
      name: "Frequency"
      id: bfreq
      accuracy_decimals: 2
      icon: "mdi:cosine-wave"
      device_class: frequency
    update_interval: 1s

  # WiFi signal strength
  - platform: wifi_signal
    name: "WiFi Signal"
    icon: "mdi:wifi"
    update_interval: 60s
    entity_category: diagnostic

  # Device uptime
  - platform: uptime
    name: "Uptime"
    icon: "mdi:clock-outline"
    entity_category: diagnostic
    update_interval: 60s

  # Pulse counter sensor
  - platform: template
    name: "Pulse Counter"
    id: pulse_counter_sensor
    icon: "mdi:counter"
    accuracy_decimals: 0
    unit_of_measurement: "pulses"
    state_class: "total_increasing"
    lambda: |-
      return id(pulse_counter);
    update_interval: never

# ===================================
# Configuration Numbers
# ===================================

number:
  - platform: template
    name: "Overheating Threshold"
    id: overheat_threshold
    icon: "mdi:thermometer-alert"
    entity_category: config
    optimistic: true
    min_value: 60
    max_value: 90
    step: 1
    initial_value: 75
    unit_of_measurement: "°C"
    restore_value: true

  - platform: template
    name: "Temperature Hysteresis"
    id: temp_hysteresis
    icon: "mdi:thermometer-lines"
    entity_category: config
    optimistic: true
    min_value: 1
    max_value: 10
    step: 1
    initial_value: 5
    unit_of_measurement: "°C"
    restore_value: true

  - platform: template
    name: "Power Limit"
    id: power_limit
    icon: "mdi:flash-alert"
    entity_category: config
    optimistic: true
    min_value: 500
    max_value: 2000  # device spec: 8A/240V ≈ 2000W max
    step: 10
    initial_value: 2000
    unit_of_measurement: "W"
    restore_value: true

# ===================================
# Configuration Selects
# ===================================

select:
  - platform: template
    name: "Relay Restore Mode"
    id: relay_restore_mode
    icon: "mdi:restore"
    entity_category: config
    optimistic: true
    options:
      - "Restore (default OFF)"
      - "Restore (default ON)"
      - "Always OFF"
      - "Always ON"
    initial_option: "Restore (default OFF)"
    restore_value: true

  - platform: template
    name: "Switch Mode"
    id: switch_mode
    icon: "mdi:toggle-switch-variant"
    entity_category: config
    optimistic: true
    options:
      - "Edge (Toggle)"
      - "Follow"
      - "Detached"
      - "Multi-Click"
      - "Pulse Counter"
    initial_option: "Edge (Toggle)"
    restore_value: true
    on_value:
      then:
        - logger.log:
            format: "Switch mode changed to: %s"
            args: ['x.c_str()']
        - if:
            condition:
              lambda: 'return x == "Pulse Counter";'
            then:
              - lambda: 'id(pulse_counter_sensor).publish_state(id(pulse_counter));'

  - platform: template
    name: "Bluetooth Scanner Mode"
    id: ble_scan_mode
    icon: "mdi:bluetooth"
    entity_category: config
    optimistic: true
    options:
      - "Disabled"
      - "Passive"
    initial_option: "Disabled"
    restore_value: true
    on_value:
      then:
        - logger.log:
            format: "BLE scan mode changed to: %s"
            args: ['x.c_str()']
        - if:
            condition:
              lambda: 'return x == "Disabled";'
            then:
              - script.execute: ble_mode_disabled
        - if:
            condition:
              lambda: 'return x == "Passive";'
            then:
              - script.execute: ble_mode_passive

# ===================================
# BLE Scan Mode Scripts
# ===================================

script:
  - id: ble_mode_disabled
    mode: restart
    then:
      - esp32_ble_tracker.stop_scan:
      - logger.log: "BLE scan disabled"

  - id: ble_mode_passive
    mode: restart
    then:
      - esp32_ble_tracker.stop_scan:
      - esp32_ble_tracker.start_scan:
          continuous: false
      - logger.log: "BLE scan passive"

  - id: restore_ble_mode
    mode: restart
    then:
      - if:
          condition:
            lambda: 'return id(ble_scan_mode).current_option() == "Passive";'
          then:
            - script.execute: ble_mode_passive
          else:
            - script.execute: ble_mode_disabled

# ===================================
# Output Control
# ===================================

output:
  - platform: gpio
    id: relay_output
    pin: GPIO5

# ===================================
# Switches
# ===================================

switch:
  - platform: template
    id: relay
    name: "Relay"
    device_class: outlet
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: |-
      return id(relay_last_state);
    turn_on_action:
      - if:
          condition:
            or:
              - lambda: |-
                  return id(temperature).state < (id(overheat_threshold).state - id(temp_hysteresis).state);
              - and:
                  - lambda: "return isnan(id(temperature).state);"
                  - binary_sensor.is_off: error_overtemp
          then:
            - output.turn_on: relay_output
            - binary_sensor.template.publish:
                id: error_overtemp
                state: OFF
            - switch.template.publish:
                id: relay
                state: ON
            - lambda: |-
                id(relay_last_state) = true;
                id(overtemp_latched) = false;
            - logger.log: "Relay turned ON"
          else:
            - logger.log: "Relay turn-on rejected: Temperature too high"
            - switch.template.publish:
                id: relay
                state: OFF
    turn_off_action:
      - output.turn_off: relay_output
      - switch.template.publish:
          id: relay
          state: OFF
      - lambda: |-
          id(relay_last_state) = false;
      - logger.log: "Relay turned OFF"

# ===================================
# Physical Inputs
# ===================================

binary_sensor:
  - platform: gpio
    name: "Switch"
    id: physical_switch
    pin: GPIO10
    filters:
      - delayed_on_off: 50ms
    on_press:
      then:
        - lambda: |-
            std::string mode = id(switch_mode).current_option();
            ESP_LOGI("switch", "Press detected, mode: %s", mode.c_str());

            if (mode == "Multi-Click") {
              ESP_LOGD("switch", "Multi-click mode: handled by on_multi_click");
              return;
            }

            if (mode == "Pulse Counter") {
              id(pulse_cycle_started) = true;
              ESP_LOGI("pulse", "Pulse cycle started (press)");

            } else if (mode == "Edge (Toggle)") {
              id(relay).toggle();

            } else if (mode == "Follow") {
              id(relay).turn_on();

            } else if (mode == "Detached") {
              ESP_LOGI("switch", "Detached mode: press event");
            }

    on_release:
      then:
        - lambda: |-
            std::string mode = id(switch_mode).current_option();
            ESP_LOGI("switch", "Release detected, mode: %s", mode.c_str());

            if (mode == "Multi-Click") {
              ESP_LOGD("switch", "Multi-click mode: handled by on_multi_click");
              return;
            }

            if (mode == "Pulse Counter") {
              if (id(pulse_cycle_started)) {
                id(pulse_counter) += 1;
                id(pulse_cycle_started) = false;
                ESP_LOGI("pulse", "Pulse counted! Total: %d", id(pulse_counter));
                id(pulse_counter_sensor).publish_state(id(pulse_counter));
              } else {
                ESP_LOGW("pulse", "Release without press - skipping count");
              }

            } else if (mode == "Follow") {
              id(relay).turn_off();

            } else if (mode == "Detached") {
              ESP_LOGI("switch", "Detached mode: release event");
            }

    on_multi_click:
      - timing:
          - state: true
            min_length: 40ms
            max_length: 1s
          - state: false
            min_length: 300ms
        then:
          - if:
              condition:
                lambda: 'return id(switch_mode).current_option() == "Multi-Click";'
              then:
                - lambda: |-
                    ESP_LOGI("multi", "Multi-click: 1 click");
                - event.trigger:
                    id: switch_single_click
                    event_type: single_click
        invalid_cooldown: 0.5s

      - timing:
          - state: true
            min_length: 40ms
            max_length: 1s
          - state: false
            min_length: 40ms
            max_length: 800ms
          - state: true
            min_length: 40ms
            max_length: 1s
          - state: false
            min_length: 300ms
        then:
          - if:
              condition:
                lambda: 'return id(switch_mode).current_option() == "Multi-Click";'
              then:
                - lambda: |-
                    ESP_LOGI("multi", "Multi-click: 2 clicks");
                - event.trigger:
                    id: switch_double_click
                    event_type: double_click
        invalid_cooldown: 0.5s

      - timing:
          - state: true
            min_length: 40ms
            max_length: 1s
          - state: false
            min_length: 40ms
            max_length: 800ms
          - state: true
            min_length: 40ms
            max_length: 1s
          - state: false
            min_length: 40ms
            max_length: 800ms
          - state: true
            min_length: 40ms
            max_length: 1s
          - state: false
            min_length: 300ms
        then:
          - if:
              condition:
                lambda: 'return id(switch_mode).current_option() == "Multi-Click";'
              then:
                - lambda: |-
                    ESP_LOGI("multi", "Multi-click: 3 clicks");
                - event.trigger:
                    id: switch_triple_click
                    event_type: triple_click
        invalid_cooldown: 0.5s

      - timing:
          - state: true
            min_length: 800ms
            max_length: 5s
        then:
          - if:
              condition:
                lambda: 'return id(switch_mode).current_option() == "Multi-Click";'
              then:
                - lambda: |-
                    ESP_LOGI("multi", "Multi-click: Long press");
                - event.trigger:
                    id: switch_long_press
                    event_type: long_press
        invalid_cooldown: 0.5s

  - platform: gpio
    name: "Button"
    pin:
      number: GPIO1
      inverted: true
      mode:
        input: true
        pullup: true
    filters:
      - delayed_on_off: 50ms

  - id: error_overtemp
    name: "Overheating"
    device_class: problem
    entity_category: diagnostic
    platform: template
    lambda: |-
      if (id(temperature).state >= id(overheat_threshold).state) {
        id(overtemp_latched) = true;
      }
      return id(overtemp_latched);
    on_press:
      then:
        - logger.log: "OVERHEATING DETECTED! Turning off relay"
        - switch.turn_off: relay
    on_release:
      then:
        - logger.log: "Temperature back to normal; latch cleared"

  - id: error_overpower
    name: "Overpower"
    device_class: problem
    entity_category: diagnostic
    platform: template
    lambda: |-
      return id(overpower_latched);
    on_press:
      then:
        - logger.log: "OVERPOWER DETECTED! Turning off relay"
        - switch.turn_off: relay
    on_release:
      then:
        - logger.log: "Power back below limit"

  - platform: template
    name: "Switch State"
    id: switch_state_sensor
    lambda: |-
      if (id(switch_mode).current_option() == "Detached") {
        return id(physical_switch).state;
      }
      return false;
    icon: "mdi:light-switch"

# ===================================
# Events (Multi-Click)
# ===================================

event:
  - platform: template
    name: "Switch Single Click"
    id: switch_single_click
    event_types:
      - single_click
    device_class: button

  - platform: template
    name: "Switch Double Click"
    id: switch_double_click
    event_types:
      - double_click
    device_class: button

  - platform: template
    name: "Switch Triple Click"
    id: switch_triple_click
    event_types:
      - triple_click
    device_class: button

  - platform: template
    name: "Switch Long Press"
    id: switch_long_press
    event_types:
      - long_press
    device_class: button

# ===================================
# Diagnostic Controls
# ===================================

button:
  - platform: restart
    name: "Restart"
    icon: "mdi:restart"
    entity_category: diagnostic

  - platform: template
    name: "Reset Pulse Counter"
    icon: "mdi:counter"
    entity_category: config
    on_press:
      then:
        - lambda: |-
            id(pulse_counter) = 0;
            id(pulse_cycle_started) = false;
            id(pulse_counter_sensor).publish_state(0);
        - logger.log: "Pulse counter reset to 0"
